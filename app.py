from datetime import datetime

import streamlit as st
from streamlit_geolocation import streamlit_geolocation

# Streamlit App UI

st.set_page_config(page_title="ğŸŠì°¸ì‹ í•œ ì œì£¼ ë§›ì§‘!")

# Replicate Credentials
with st.sidebar:
    st.title("ğŸŠì°¸ì‹ í•œ! ì œì£¼ ë§›ì§‘")

    st.write("")

    st.subheader("ì–¸ë“œë ˆ ê°€ì‹ ë””ê°€?")

    # selectbox ë ˆì´ë¸” ê³µë°± ì œê±°
    st.markdown(
        """
        <style>
        .stSelectbox label {  /* This targets the label element for selectbox */
            display: none;  /* Hides the label element */
        }
        .stSelectbox div[role='combobox'] {
            margin-top: -20px; /* Adjusts the margin if needed */
        }
        </style>
        """,
        unsafe_allow_html=True,
    )

    time = st.sidebar.selectbox("", ["ì•„ì¹¨", "ì ì‹¬", "ì˜¤í›„", "ì €ë…", "ë°¤"], key="time")

    st.write("")

    st.subheader("ì–´ë“œë ˆê°€ ë§˜ì— ë“œì‹ ë””ê°€?")

    # radio ë ˆì´ë¸” ê³µë°± ì œê±°
    st.markdown(
        """
        <style>
        .stRadio > label {
            display: none;
        }
        .stRadio > div {
            margin-top: -20px;
        }
        </style>
        """,
        unsafe_allow_html=True,
    )

    local_choice = st.radio("", ("ì œì£¼ë„ë¯¼ ë§›ì§‘", "ê´€ê´‘ê° ë§›ì§‘"))

    # Group location-related inputs into an expandable box
    with st.expander("Location Settings", expanded=True):
        use_current_location = st.checkbox("í˜„ì¬ ì •ë³´ í™œìš©")
        location = streamlit_geolocation()
        latitude = st.number_input("ìœ„ë„", format="%.6f", value=location["latitude"])
        longitude = st.number_input("ê²½ë„", format="%.6f", value=location["longitude"])

        st.time_input("í˜„ì¬ ì‹œê°„", value=datetime.now())
        weekdays = [
            "ì›”ìš”ì¼",
            "í™”ìš”ì¼",
            "ìˆ˜ìš”ì¼",
            "ëª©ìš”ì¼",
            "ê¸ˆìš”ì¼",
            "í† ìš”ì¼",
            "ì¼ìš”ì¼",
        ]
        selected_weekday = st.selectbox(
            "ìš”ì¼ ì„ íƒ", weekdays, index=datetime.now().weekday()
        )

    devmode = st.checkbox("dev ëª¨ë“œ (SQLì¿¼ë¦¬ ì¶œë ¥)")

st.title("í˜¼ì € ì˜µì„œì˜ˆ!ğŸ‘‹")
st.subheader("êµ°ë§›ë‚œ ì œì£¼ ë°¥ì§‘ğŸ§‘â€ğŸ³ ì¶”ì²œí•´ë“œë¦´ê²Œì˜ˆ")

st.write("")

st.write(
    "#í‘ë¼ì§€ #ê°ˆì¹˜ì¡°ë¦¼ #ì˜¥ë”êµ¬ì´ #ê³ ì‚¬ë¦¬í•´ì¥êµ­ #ì „ë³µëšë°°ê¸° #í•œì¹˜ë¬¼íšŒ #ë¹™ë–¡ #ì˜¤ë©”ê¸°ë–¡..ğŸ¤¤"
)

st.write("")

image_path = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRTHBMuNn2EZw3PzOHnLjDg_psyp-egZXcclWbiASta57PBiKwzpW5itBNms9VFU8UwEMQ&usqp=CAU"
image_html = f"""
<div style="display: flex; justify-content: center;">
    <img src="{image_path}" alt="centered image" width="50%">
</div>
"""
st.markdown(image_html, unsafe_allow_html=True)

st.write("")

# Store LLM generated responses
if "messages" not in st.session_state.keys():
    st.session_state.messages = [
        {"role": "assistant", "content": "ì–´ë“œëŸ° ì‹ë‹¹ ì°¾ìœ¼ì‹œì¿ ê³¼?"}
    ]

# Display or clear chat messages
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.write(message["content"])


def clear_chat_history():
    st.session_state.messages = [
        {"role": "assistant", "content": "ì–´ë“œëŸ° ì‹ë‹¹ ì°¾ìœ¼ì‹œì¿ ê³¼?"}
    ]


st.sidebar.button("Clear Chat History", on_click=clear_chat_history)


# User-provided prompt
if prompt := st.chat_input():  # (disabled=not replicate_api):
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.write(prompt)

# Generate a new response if last message is not from assistant
if st.session_state.messages[-1]["role"] != "assistant":
    with st.chat_message("assistant"):
        with st.spinner("Thinking..."):
            # Pass latitude and longitude to the response generator
            response = "Nothing"
            st.markdown(response)
    message = {"role": "assistant", "content": response}
    st.session_state.messages.append(message)
